<?xml version="1.0" encoding="UTF-8"?>

<!--
  Copyright (C) 2008 Carlos III University of Madrid
  This file is part of the ADA: Agile Distributed Authoring Toolkit

  This program is free software; you can redistribute it and/or
  modify it under the terms of the GNU General Public License
  as published by the Free Software Foundation; either version 2
  of the License, or (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin Street, Fifth Floor
  Boston, MA  02110-1301, USA.

-->

<project name="Apply xsltproc and a style to a given file list"
	 default="xsltproc">

  <description>
    Apply a XSL stylesheet to a set of XML files.
  </description>

  <!--
      Given the following properties:

      xsltproc.src.dir: directory from where to take the source files
      xsltproc.dst.dir: directory where the produced files are stored
      xsltproc.files: List of files to process
      xsltproc.style.file: Style file to be used
      xsltproc.output.format: Extension of the output file
      xsltproc.extra.args: Extra arguments to invoke xsltproc
      xsltproc.files: Comma separate list of files to process

      Produce the aplication of a stylefile to the files in xsltproc.fileset
  -->

  <import file="InitialCheck.xml"/>

  <property name="xsltproc.exec"           value="xsltproc"
	    description="Name of the XSLT processor executable"/>

  <ada.set.execution.possible ADA.EXECUTABLE.NAME="${xsltproc.exec}"/>
  
  <!-- Private properties -->
  <property name="xsltproc.debug.level"    value="${ada.debug.level}"
	    description="Debug level to apply to these rules (see ada.debug.level)"/>

  <target name="xsltproc.init" depends="ada.init" if="xsltproc.execution.possible">

    <!-- Public Property definition -->
    <property name="xsltproc.src.dir"           value="${basedir}"
	      description="Directory where the sources are taken"/>
    <property name="xsltproc.dst.dir"           value="${basedir}"
	      description="Directory where the produced files are created"/>
    <property name="xsltproc.style.file"
              value="${ada.home}/ADA_Styles/DocbookProfile.xsl"
	      description="Full path to the stylesheet file"/>
    <property name="xsltproc.output.format"     value=".html"
	      description="Output file has the same name as the source but the
extension is replaced &#10;# by this value"/>
    <property name="xsltproc.extra.args"        value=""
	      description="Extra arguments to pass to the XSLT processor"/>
    <property name="xsltproc.files"             value=""
	      description="Source file names (no path, it is xsltproc.src.dir)"/>
    <property name="xsltproc.multilingual.files" value=""
	      description="Source file names (no path) to process in
multilingual mode"/>
    <property name="xsltproc.mergestyles.style.file"     
	      value="${ada.home}/ADA_Styles/Mergesheets.xsl"/>
    <property name="mergestyles.master.style"   value=""
	      description="An additional stylesheet to combine with
xsltproc.style.file"/>

    <property name="xsltproc.profile.lang"        value=""
	      description="Defaul language to consider when processing documents"/>
    <condition property="xsltproc.profile.lang.suffix"
               value="_${xsltproc.profile.lang}"
	       else="">
      <not><equals arg1="${xsltproc.profile.lang}" arg2="" trim="true"/></not>
    </condition>

    <!-- 
	 The paramater l10n.gentext.language takes its value from the presence of
	 the attribute lang or xml:lang in any of the ancestors of a node. This
	 does not work when processing a multi-language document in which that
	 attribute is not at the root of the document but in elements deeper in
	 the hierarchy. One consequence, for example is that it renders "Table of
	 Contents" despite processing a document with profile.lang = es. The
	 assignment forces l10n.gentext.language to have the same value.
    -->
    <condition property="xsltproc.profile.lang.option"
               value="--stringparam profile.lang ${xsltproc.profile.lang}
		      --stringparam l10n.gentext.language ${xsltproc.profile.lang}"
               else="">
      <not><equals arg1="${xsltproc.profile.lang}" arg2="" trim="true"/></not>
    </condition>

    <!--
	Set the value of several options to include entire option values
	depending on the value of a variable. This is to avoid empty strings in
	the command line because of the difference between windows and Unix with
	java.exe
    -->
    <condition property="xsltproc.ada.current.datetime.option"
               value="--stringparam ada.current.datetime ${ada.current.datetime}"
               else="">
      <not><equals arg1="${ada.current.datetime}" arg2="" trim="true"/></not>
    </condition>
    <condition property="xsltproc.ada.profile.revision.option"
               value="--stringparam profile.revision ${ada.profile.revision}"
               else="">
      <not><equals arg1="${ada.profile.revision}" arg2="" trim="true"/></not>
    </condition>
    
    <!-- Define two properties containing the absolute src and dst paths -->
    <ada.expand.srcdst.paths
      ADA.PREFIX="xsltproc" ADA.SRC.DIR="${xsltproc.src.dir}"
      ADA.DST.DIR="${xsltproc.dst.dir}" ADA.FILES="${xsltproc.files}"/>

    <!-- Multilingual source files to be processed (fileset to allow wildcards) -->
    <fileset id="xsltproc.multilingual.fileset" dir="${xsltproc.abssrc.dir}"
	     includes="___bogus___file__name ${xsltproc.multilingual.files}"/>
    
    <!-- Obtain the filelist with the source files to see if it is empty -->
    <pathconvert property="xsltproc.multilingual.source.filelist.property" pathsep=" ">
      <fileset refid="xsltproc.multilingual.fileset"/>
    </pathconvert>

    <!-- Obtain the filelist with the produced files. -->
    <pathconvert property="xsltproc.target.filelist.property" pathsep=" ">
      <fileset refid="xsltproc.fileset"/>
      <chainedmapper>
	<mapper type="glob" from="${xsltproc.abssrc.dir}/*" 
		to="${xsltproc.absdst.dir}/*"/>
	<compositemapper>
	  <mapper type="glob" from="*.xml" 
		  to="*${xsltproc.profile.lang.suffix}${xsltproc.output.format}"/>
	  <mapper type="glob" from="*.xsl" 
		  to="*${xsltproc.profile.lang.suffix}${xsltproc.output.format}"/>
	</compositemapper>
      </chainedmapper>
    </pathconvert>
    <filelist id="xsltproc.target.filelist"
	      files="${xsltproc.target.filelist.property}"/>
    
    <!-- Bomb out if incorrect stylesheet -->
    <fail message="File ${xsltproc.style.file} not found">
      <condition>
	<and>
	  <!-- Require a non-empty style file -->
	  <not><equals arg1="${xsltproc.style.file}" arg2="" trim="true"/></not>
	  <not><available file="${xsltproc.style.file}"/></not>
	  <not><available
	  file="${ada.home}/ADA_Styles/${xsltproc.style.file}"/></not>
	</and>
      </condition>
    </fail>

    <!-- Condition to enable/disable the rest of the execution -->
    <condition property="xsltproc.check">
      <and>
	<!-- 
	     There must be some files in the fileset (after regexp expansion) 
	-->
	<not>
	  <equals arg1="${xsltproc.source.filelist.property}" arg2="" trim="true"/>
	</not>
      </and>
    </condition>

    <!-- Condition to enable/disable multilingual the execution -->
    <condition property="xsltproc.multilingual.check">
      <!-- 
	   There must be some files in the fileset (after regexp expansion) 
      -->
      <not>
	<equals arg1="${xsltproc.multilingual.source.filelist.property}"
		arg2="" trim="true"/>
      </not>
    </condition>

    <macrodef name="xsltproc.execute">
      <attribute name="DIR"/>
      <attribute name="XSLTPROC.ABSDST.DIR"/>
      <attribute name="XSLTPROC.EXTRA.ARGS"/>
      <attribute name="XSLTPROC.STYLE.FILE"/>
      <element name="fileset.and.mapper" implicit="yes"/>
      <sequential>
	<!-- Execute the command. Watch out for src.dir and dst.dir -->
	<apply dir="@{DIR}" parallel="false" dest="@{XSLTPROC.ABSDST.DIR}" 
	       append="yes" failonerror="true" executable="${xsltproc.exec}" 
	       output="build.out">
	  <arg value="--nonet"/>
	  <arg value="--path"/>
	  <arg value=".:${ada.home.unix}/ADA_Styles"/>
	  <arg value="--xinclude"/>
	  <arg value="--stringparam"/>
	  <arg value="ada.home"/>
	  <arg value="${ada.home}"/>
	  <arg value="--stringparam"/>
	  <arg value="basedir"/>
	  <arg value="${basedir}"/>
	  <arg value="--stringparam"/>
	  <arg value="ada.course.home"/>
	  <arg value="${ada.course.home}"/>
	  <arg line="${xsltproc.ada.current.datetime.option}"/>
	  <arg line="${xsltproc.ada.profile.revision.option}"/>
	  <arg line="${xsltproc.profile.lang.option}"/>
	  <arg line="@{XSLTPROC.EXTRA.ARGS}"/>
	  <arg value="-o"/>
	  <targetfile/>
	  <arg value="@{XSLTPROC.STYLE.FILE}"/>
	  <fileset.and.mapper />
	</apply>
      </sequential>
    </macrodef>

    <macrodef name="mergestyles">
      <attribute name="MERGESTYLES.DST.DIR" default="${xsltproc.dst.dir}"/>
      <attribute name="MERGESTYLES.FILE.TO.IMPORT"/>
      <sequential>

	<!-- Turn mergestyles.master.file to a fileset -->
	<fileset id="mergestyles.master.fileset" 
		 file="${mergestyles.master.style}"/>

	<pathconvert property="mergestyles.output.prefix">
	  <fileset refid="mergestyles.master.fileset"/>
	  <chainedmapper>
	    <compositemapper>
	      <mapper type="glob" from="*.xml" to="*"/>
	      <mapper type="glob" from="*.xsl" to="*"/>
	    </compositemapper>
	    <mapper type="flatten"/>
	  </chainedmapper>
	</pathconvert>
	<pathconvert property="mergestyles.output.suffix">
	  <filelist id="mergestyles.import.filelist" 
		    files="@{MERGESTYLES.FILE.TO.IMPORT}"/>
	  <mapper type="flatten"/>
	</pathconvert>

	<!-- Create the dst directory -->
	<mkdir dir="@{MERGESTYLES.DST.DIR}" />
	
	<exec executable="cygpath" osfamily="windows"
	      outputproperty="mergestyle.file.to.import.new.value">
	  <arg value="-u"/>
	  <arg value="@{MERGESTYLES.FILE.TO.IMPORT}"/>
	</exec>

	<condition property="mergestyle.file.to.import.formatted"
		   value="${mergestyle.file.to.import.new.value}">
	  <os family="windows"/>
	</condition>

	<condition property="mergestyle.file.to.import.formatted"
		   value="@{MERGESTYLES.FILE.TO.IMPORT}">
	  <os family="unix"/>
	</condition>

	<!-- Force the dependency checking on changes on the style sheet -->
	<dependset>
	  <srcfileset file="${ada.local.property.file}" />
	  <srcfileset file="${xsltproc.mergestyles.style.file}" />
	  <srcfileset file="@{MERGESTYLES.FILE.TO.IMPORT}" />
	  <targetfilelist 
	    dir="@{MERGESTYLES.DST.DIR}"
	    files="${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${mergestyles.output.suffix}"/>
	</dependset>
	
	<!-- Execute the command. Watch out for src.dir and dst.dir -->
	<apply dir="${basedir}" parallel="false"
	       dest="@{MERGESTYLES.DST.DIR}" append="yes" failonerror="true"
	       executable="${xsltproc.exec}"  output="build.out">
	  <arg value="--nonet"/>
	  <arg value="--path"/>
	  <arg value=".:${ada.home.unix}/ADA_Styles"/>
	  <arg value="--xinclude"/>
	  <arg value="--stringparam"/>
	  <arg value="mergesheets.file.to.fold"/>
	  <arg value="${mergestyle.file.to.import.formatted}"/>
	  <arg value="--stringparam"/>
	  <arg value="ada.profile.suppress.profiling.attributes"/>
	  <arg value="yes"/>
	  <arg line="${xsltproc.profile.lang.option}"/>
	  <arg value="-o"/>
	  <targetfile/>
	  <arg value="${xsltproc.mergestyles.style.file}"/>
	  <fileset refid="mergestyles.master.fileset"/>
	  <!-- Mapper from source files to produced files -->
	  <compositemapper>
	    <mapper type="glob" from="*.xsl" 
		    to="*${xsltproc.profile.lang.suffix}_${mergestyles.output.suffix}"/>
	    <mapper type="glob" from="*.xml" 
		    to="*${xsltproc.profile.lang.suffix}_${mergestyles.output.suffix}"/>
	  </compositemapper>
	</apply>
      </sequential>
    </macrodef>

    <macrodef name="mergestyles.clean">
      <attribute name="MERGESTYLES.DST.DIR" default="${xsltproc.dst.dir}"/>
      <attribute name="MERGESTYLES.FILE.TO.IMPORT"/>
      <sequential>
	<!-- Style to merge -->
	<fileset id="mergestyles.master.fileset" file="${mergestyles.master.style}"/>

	<pathconvert property="mergestyles.output.prefix">
	  <fileset refid="mergestyles.master.fileset"/>
	  <chainedmapper>
	    <mapper type="glob" from="*.xml" to="*"/>
	    <mapper type="flatten"/>
	  </chainedmapper>
	</pathconvert>
	<pathconvert property="mergestyles.output.suffix">
	  <filelist id="mergestyles.import.filelist" 
		    files="@{MERGESTYLES.FILE.TO.IMPORT}"/>
	  <mapper type="flatten"/>
	</pathconvert>

	<!-- Dump explicitly the files to be deleted -->
	<echo> deleted = ${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${mergestyles.output.suffix}</echo>

	<delete
	  file="@{MERGESTYLES.DST.DIR}/${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${mergestyles.output.suffix}"/>
      </sequential>
    </macrodef>

    <!-- Bomb out if incorrect merge stylesheet -->
    <fail message="File ${mergestyles.master.style} not found">
      <condition>
	<and>
	  <!-- Non-empty merge style and not available -->
	  <not><equals arg1="${mergestyles.master.style}" arg2="" trim="true"/></not>
	  <not><available file="${mergestyles.master.style}"/></not>
	</and>
      </condition>
    </fail>

    <!-- Condition to detect if the stylefile needs to be pre-processed with
	 Mergestyles -->
    <condition property="xsltproc.mergestyles">
      <and>
	<istrue value="${xsltproc.check}"/>
	<not><equals arg1="${mergestyles.master.style}" arg2="" trim="true"/></not>
	<available file="${mergestyles.master.style}"/>
      </and>
    </condition>
    
    <!-- Condition to detect if the stylefile needs to only processed normally
	 Mergestyles -->
    <condition property="xsltproc.nomergestyles">
      <and>
	<istrue value="${xsltproc.check}"/>
	<equals arg1="${mergestyles.master.style}" arg2="" trim="true"/>
      </and>
    </condition>
    
    <!-- Dump the value of the properties just computed. -->
    <echo level="${xsltproc.debug.level}">  xsltproc.check          = "${xsltproc.check}"
  xsltproc.execution.possible = ${xsltproc.execution.possible}
  xsltproc.multilingual.check = ${xsltproc.multilingual.check}</echo>
  </target>

  <!-- Regular target. It is executed if the check property is true -->
  <target name="xsltproc.processing" 
	  depends="xsltproc.init, xsltproc.prepare.processing,
		   xsltproc.execute.nopreprocessing.step,
		   xsltproc.execute.preprocessing.step"
	  description="Apply a style to an XML file"/>

  <!-- Multilingual processing instructions -->
  <target name="xsltproc.multilingual.processing"
	  depends="xsltproc.init" if="xsltproc.multilingual.check">
    <subant target="xsltproc.processing">
      <fileset dir="${ada.home}/AntImports" includes="Xsltproc-*.xml"/>
      <property name="xsltproc.files" value="${xsltproc.multilingual.files}"/>
      <property name="xsltproc.multilingual.files" value=""/>
      <property name="ada.course.home.candidate" value="${ada.course.home}"/>
    </subant>
  </target>

  <target name="xsltproc.prepare.processing" if="xsltproc.check">
    <!-- Create the dst directory -->
    <mkdir dir="${xsltproc.dst.dir}" />
  </target>

  <target name="xsltproc.execute.nopreprocessing.step"
	  if="xsltproc.nomergestyles"
	  description="Apply a style to an XML file WITH NO pre-processing">
    <echo>xsltproc.processing.nopre   RUN</echo>
    <echo level="${xsltproc.debug.level}">${basedir}</echo>

    <pathconvert property="xsltproc.source.dependency.property" pathsep=" ">
      <fileset refid="xsltproc.fileset"/>
    </pathconvert>

    <exec executable="bash" failonerror="true"
	  dir="${basedir}" logError="yes"
	  outputproperty="xsltproc.dependency.files">
      <arg value="${ada.home}${file.separator}bin${file.separator}getdependencies.sh"/>
      <arg value="${xsltproc.source.dependency.property}"/>
      <arg value="${xsltproc.style.file}"/>
    </exec>

    <echo
      level="${xsltproc.debug.level}">xsltproc.dependency.files=${xsltproc.dependency.files}
xsltproc.source.dependency.property=${xsltproc.source.dependency.property}</echo>

    <!-- Force the dependency checking on changes on the style sheet -->
    <dependset>
      <srcfileset file="${ada.local.property.file}" />
      <srcfileset file="${xsltproc.style.file}" />
      <srcfileset dir="${ada.course.home}">
	<include name="AdaCourseParams.xml" />
	<include name="Ada.properties" />
      </srcfileset>
      <!-- 
	   Attention: This filelist is not legal because it has no dir, but all
	   the paths are absolute, therefore, there is no need for it. If an
	   empty dir attribute is inserted, the dependencies break. I left it
	   like that on purpose.
      -->
      <srcfilelist files="${xsltproc.dependency.files}"/>
      <targetfilelist refid="xsltproc.target.filelist" />
    </dependset>

    <!-- Execute the command. Watch out for abssrc.dir and absdst.dir -->
    <xsltproc.execute DIR="${xsltproc.abssrc.dir}"
		  XSLTPROC.ABSDST.DIR="${xsltproc.absdst.dir}"
		  XSLTPROC.EXTRA.ARGS="${xsltproc.extra.args}"
		  XSLTPROC.STYLE.FILE="${xsltproc.style.file}">
      <fileset refid="xsltproc.fileset"/>
      <!-- Mapper from source files to produced files -->
      <compositemapper>
	<mapper type="glob" from="*.xml" 
		to="*${xsltproc.profile.lang.suffix}${xsltproc.output.format}"/>
	<mapper type="glob" from="*.xsl" 
		to="*${xsltproc.profile.lang.suffix}${xsltproc.output.format}"/>
      </compositemapper>
    </xsltproc.execute>
  </target>

  <target name="xsltproc.execute.preprocessing.step"
	  if="xsltproc.mergestyles"
	  description="Apply a style to an XML file WITH pre-processing">
    <echo>xsltproc.processing.prepr   RUN</echo>
    <echo level="${xsltproc.debug.level}">${basedir}</echo>

    <!-- Merge stylesheets -->
    <mergestyles MERGESTYLES.FILE.TO.IMPORT="${xsltproc.style.file}"/>

    <!-- Flatten the import filelist to get the suffix for the new style -->
    <pathconvert property="xsltproc.output.suffix">
      <filelist files="${xsltproc.style.file}"/>
      <mapper type="flatten"/>
    </pathconvert>

    <echo level="${xsltproc.debug.level}">xsltproc processed stylefile: ${xsltproc.absdst.dir}/${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${xsltproc.output.suffix}</echo>

    <echo level="${xsltproc.debug.level}">Srcfileset: ${xsltproc.absdst.dir}/${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${xsltproc.output.suffix}</echo>

    <pathconvert property="xsltproc.source.dependency.property" pathsep=" ">
      <fileset refid="xsltproc.fileset"/>
    </pathconvert>

    <exec executable="bash" failonerror="true"
	  dir="${basedir}" logError="yes"
	  outputproperty="xsltproc.dependency.files">
      <arg value="${ada.home}${file.separator}bin${file.separator}getdependencies.sh"/>
      <arg value="${xsltproc.source.dependency.property}"/>
      <arg value="${xsltproc.absdst.dir}${file.separator}${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${xsltproc.output.suffix}"/>
    </exec>

    <echo
      level="${xsltproc.debug.level}">xsltproc.dependency.files=${xsltproc.dependency.files}
xsltproc.source.dependency.property=${xsltproc.source.dependency.property}</echo>

    <!-- Force the dependency checking on changes on the style sheet -->
    <dependset>
      <srcfileset file="${ada.local.property.file}" />
      <srcfileset
	file="${xsltproc.absdst.dir}/${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${xsltproc.output.suffix}"/>
      <srcfileset dir="${ada.course.home}">
	<include name="AdaCourseParams.xml" />
	<include name="Ada.properties" />
      </srcfileset>
      <!-- 
	   Attention: This filelist is not legal because it has not dir, but all
	   the paths are absolute, therefore, there is no need for it. If an
	   empty dir attribute is inserted, the dependencies break. I left it
	   like that on purpose.
      -->
      <srcfilelist files="${xsltproc.dependency.files}"/>
      <targetfilelist refid="xsltproc.target.filelist" />
    </dependset>

    <!-- Execute the command. Watch out for src.dir and dst.dir -->
    <xsltproc.execute DIR="${xsltproc.abssrc.dir}"
		  XSLTPROC.ABSDST.DIR="${xsltproc.absdst.dir}"
		  XSLTPROC.EXTRA.ARGS="${xsltproc.extra.args}"
		  XSLTPROC.STYLE.FILE="${xsltproc.absdst.dir}${file.separator}${mergestyles.output.prefix}${xsltproc.profile.lang.suffix}_${xsltproc.output.suffix}">
      <fileset refid="xsltproc.fileset"/>
      <!-- Mapper from source files to produced files -->
      <compositemapper>
	<mapper type="glob" from="*.xml" 
		to="*${xsltproc.profile.lang.suffix}${xsltproc.output.format}"/>
	<mapper type="glob" from="*.xsl" 
		to="*${xsltproc.profile.lang.suffix}${xsltproc.output.format}"/>
      </compositemapper>
    </xsltproc.execute>

  </target>

  <!-- Clean files produced by xsltproc -->
  <target name="xsltproc.clean" 
	  depends="xsltproc.init, xsltproc.mergestyles.clean, 
		   xsltproc.nomergestyles.clean"
	  if="xsltproc.check" description="Remove files produced by xsltproc"/>

  <target name="xsltproc.nomergestyles.clean" depends="xsltproc.init"
	  description="Clean those files produced with no mergestyles">

    <echo>xsltproc.clean              RUN(nomerge)</echo>
    <echo level="${xsltproc.debug.level}">${basedir}</echo>

    <!-- Dump explicitly the files to be deleted -->
    <echo> deleted = ${xsltproc.target.filelist.property}</echo>

    <!-- Perform the delete operation. The failonerror attribute is needed
	 and must be set fo false because the dst directory might have been
	 removed  -->
    <delete failonerror="false" includeemptydirs="true">
      <files includes="${xsltproc.target.filelist.property}"/>
    </delete>
  </target>

  <target name="xsltproc.mergestyles.clean" depends="xsltproc.init"
	  if="xsltproc.mergestyles" description="Clean if Mergestyles is used">
    <!-- This call has no effect if no mergestyles.master.style is given -->

    <echo>xsltproc.clean              RUN(merge)</echo>
    <echo level="${xsltproc.debug.level}">${basedir}</echo>

    <mergestyles.clean MERGESTYLES.FILE.TO.IMPORT="${xsltproc.style.file}"/>
  </target>

  <!-- Multilingual processing instructions -->
  <target name="xsltproc.multilingual.clean"
	  depends="xsltproc.init" if="xsltproc.multilingual.check">
    <subant target="xsltproc.clean" inheritall="false">
      <fileset dir="${ada.home}/AntImports" includes="Xsltproc-*.xml"/>
      <property name="xsltproc.files" value="${xsltproc.multilingual.files}"/>
    </subant>
  </target>

  <!-- Dump the properties defined in this script -->
  <target name="xsltproc.dump.properties" depends="xsltproc.init">
    <echo level="${xsltproc.debug.level}"> ------ xsltproc properties ----
    xsltproc.exec            ="${xsltproc.exec}"
    xsltproc.abssrc.dir ="${xsltproc.abssrc.dir}"
    xsltproc.absdst.dir ="${xsltproc.absdst.dir}"
    xsltproc.style.file      ="${xsltproc.style.file}"
    xsltproc.output.format   ="${xsltproc.output.format}"
    xsltproc.extra.args      ="${xsltproc.extra.args}"
    xsltproc.files           ="${xsltproc.files}"
    xsltproc.target.filelist ="${xsltproc.target.filelist.property}"
    xsltproc.mergestyles     ="${xsltproc.mergestyles}"
    xsltproc.profile.lang    ="${xsltproc.profile.lang}"
    xsltproc.profile.lang.suffix="${xsltproc.profile.lang.suffix}"
    xsltproc.profile.lang.option="${xsltproc.profile.lang.option}"
    mergestyles.master.style="${mergestyles.master.style}"</echo>
  </target>

  <target name="xsltproc.report.YES" depends="xsltproc.init"
	  if="xsltproc.execution.possible">
    <echo>Xsltproc           |     *     |</echo>
  </target>

  <target name="xsltproc.report.NO" depends="xsltproc.init"
	  unless="xsltproc.execution.possible">
    <echo>Xsltproc           |           |     * (install ${xsltproc.exec})</echo>
  </target>

  <target name="xsltproc.report" depends="xsltproc.report.YES,
				      xsltproc.report.NO"/>

  <!-- If entering through this target, build.out is deleted -->
  <target name="xsltproc" depends="xsltproc.init, initial.delete.build.out, xsltproc.processing"/>

  <target name="xsltproc.multilingual" depends="xsltproc.init, initial.delete.build.out, xsltproc.multilingual.processing"/>
</project>
