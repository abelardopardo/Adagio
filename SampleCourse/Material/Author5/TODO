--------------------------------------------------------------------------------
* En searchFrame se hace:

        /* Remember the first free position */
        if (pageSet[i].pid == 0 && freeIdx == -1) {
            freeIdx = i;
        }

  se utiliza el hecho de que el PID es cero en las entradas
  vacías. Sin embargo lo que no he visto es en removePages:

  void removePages(int pid) {
    int i;
    for (i = 0; i < NUM_FRAMES; i++) {
        if (pageSet[i].pid != pid) {
            continue;
        }

        releaseFrame(i);
        freePages++;
    }
}

  donde se pone el PID a cero para indicar que las entradas que se liberan
  se quedan vacías. ¿Es esto un error o se ha hecho con alguna finalidad?
  ¿Se llega esto a probar? (es decir, mueren procesos por el medio de la
  ejecución o mueren todos al final)

FIXED: En cuanto puse una línea que se cargaba un proceso a mitad de simulación
saltó un error. Por tanto, solo con hacer esto, ya se detecta. También está
corregida la solución, por supuesto.

--------------------------------------------------------------------------------

* There is a problem with the NUM_FRAMES constant. If frames.c is given to the
* students, then there is no problem, but if such file is given as a binary
* file, then the possibility of compiling the executable with a different
* constant value is no longer feasible since it leads to executables in which
* different portions of the code have different values for such constant.

FIXED. NUM_FRAMES was removed from the compilation command.

--------------------------------------------------------------------------------
* In the wording of the lab, the second parameter is said to be the set of pages
* over which a process accesses. This is very confussing. What in fact this
* parameter does is define the size of the window to slide over the space of
* page numbers in order to select the next access. A new wording is needed to
* clarify this issue.

--------------------------------------------------------------------------------
* Also, a bug was discovered in the runTests script which is very likely present
* in some other scripts (since they keep being derived from the previous one).
* When the status of the execution is checked and found incorrect (that is, a
* seg fault has been found), the script executes a "continue" instead of the
* proper "breaksw". I removed the continue and uncommented the breaksw but it is
* very likely there are other scripts from the previous labs with the same
* defficiency.

FIXED. Script  was redone in PERL and now is working

--------------------------------------------------------------------------------
* Do not reuse this lab for at least a couple of years since the solution it's
* begun to circulate.

FIXED: Forget it. Who cares!
--------------------------------------------------------------------------------
* Replacement policies may vary from FIFO to LRU. However, there is a
* replacement policy which is simply to keep a global counter and increase its
* value every time a replacement needs to be done. We need an example that
* severily penalizes such heuristic and favors LRU and FIFO.

--------------------------------------------------------------------------------
* Invoke first to removePage before searchFrame to detect those that go directly
* to removing before checking if the page is there.

FIXED. releaseFrame now bombs out when there no frame occupied

--------------------------------------------------------------------------------
* Rank is not working. It ranks opposite than expected!!

FIXED
--------------------------------------------------------------------------------
